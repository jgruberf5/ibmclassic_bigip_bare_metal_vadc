#!/bin/bash

export script_dir=/opt/F5Networks/onboarding


if [ -f "/etc/bigip" ]; then
    source /etc/bigip
fi


function set_permissions {
    chmod +x $script_dir/scripts/start
    chmod +x $script_dir/scripts/stop
}


function assure_packages {
  echo "Installing hypervisor and qemu agent requirements"
  apt update
  for pkg in bridge-utils cpu-checker libvirt-clients libvirt-daemon libvirt-daemon-system qemu qemu-kvm genisoimage; do
      installed=$(dpkg-query -W --showformat='${Status}\n' $pkg|grep "install ok installed"|wc -l)
      if [ "$installed" -ne "1" ]; then
          apt install -y $pkg
      fi 
  done
}


function create_netplan {
    echo "Creating BIG-IP virtual edition management access and activating SR-IOV virtual functions"
    
    NETPLAN_ACTIVE=/etc/netplan/01-netcfg.yaml
    NETPLAN_BACKUP=/opt/F5Networks/onboarding/netplan-orginial.yaml
    # original copy needed
    if ! [ -e $NETPLAN_BACKUP ]; then
      cp $NETPLAN_ACTIVE $NETPLAN_BACKUP
    fi
    
    # Read IP from bond0 (private) and populate BIG-IP netplan YAML to move IP address to bridge with BIG-IP management port
    #
    # This method uses linux network settings - assumes networking is up
    #PRIVATE_INTERFACE=bond0
    #PRIVATE_IP_ADDRESS=$(ip addr show $PRIVATE_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
    #PRIVATE_IP_MASK=$(ip addr show $PRIVATE_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f2)
    #PRIVATE_NEXT_HOP=$(ip route show 10.0.0.0/8 | awk '{print $3}')
    #
    # This method uses the existing Ubuntu netplan YAML for IBM Classic bare metal servers
    # If the default netplan changes, this will need to be adjusted
    #
    # private ip addres = networks.bonds.bond0.address.0
    # private ip next hop = networks.bonds.bond0.routes.0.via
    #
    PRIVATE_IP_ADDRESS=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["addresses"][0])'| cut -d'/' -f1)
    PRIVATE_IP_MASK=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["addresses"][0])'| cut -d'/' -f2)
    PRIVATE_NEXT_HOP=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["routes"][0]["via"])')

    # Read IP from bond1 (public) and populate BIG-IP netplan YAML
    #
    # This method uses linux network settings - assumes networking is up
    #PUBLIC_INTERFACE=bond1
    #PUBLIC_IP_ADDRESS=$(ip addr show $PUBLIC_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
    #PUBLIC_IP_MASK=$(ip addr show $PUBLIC_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f2)
    #PUBLIC_NEXT_HOP=$(ip route show default | awk '{print $3}')
    #
    # This method uses the existing Ubuntu netplan YAML for IBM Classic bare metal servers
    # If the default netplan changes, this will need to be adjusted
    #
    # public ip addres = networks.bonds.bond1.address.0
    # public ip next hop = networks.bonds.bond1.gateway4
    #
    PUBLIC_IP_ADDRESS=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond1"]["addresses"][0])' | cut -d'/' -f1)
    PUBLIC_IP_MASK=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond1"]["addresses"][0])' | cut -d'/' -f2)
    PUBLIC_NEXT_HOP=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond1"]["gateway4"])')
    #
    # Read DNS server for private DNS servers
    #
    # This method uses what is statically set in the linux resolver config - assumes netplan has created the config
    #DNS_1=$(cat /etc/resolv.conf | grep -m 1 nameserver | awk '{ print $2 }')
    #DNS_2=$(cat /etc/resolv.conf | grep -m 2 nameserver | tail -n1 | awk '{ print $2 }')
    #
    # This method uses the existing Ubuntu netplan YAML for IBM Classic bare metal servers
    # If the default netplan changes, this will need to be adjusted
    #
    export DNS_1=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][0])')
    export DNS_2=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][1])')
    #
    NETPLAN_TEMPLATE="$script_dir/netplan_template.yaml"
    NETPLAN_OUTPUT="$script_dir/netplan.yaml"

    third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
    third=$((16#$third))
    fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
    fourth=$((16#$fourth))
    HOST_LINK_LOCAL_MANAGEMENT_IP="169.254.$third.$fourth/16"

    cp $NETPLAN_TEMPLATE $NETPLAN_OUTPUT
    sed -i "s|__DNS_1__|$DNS_1|g" $NETPLAN_OUTPUT
    sed -i "s|__DNS_2__|$DNS_2|g" $NETPLAN_OUTPUT
    sed -i "s|__PUBLIC_IP_ADDRESS__|$PUBLIC_IP_ADDRESS|g" $NETPLAN_OUTPUT
    sed -i "s|__PUBLIC_IP_MASK__|$PUBLIC_IP_MASK|g" $NETPLAN_OUTPUT
    sed -i "s|__PUBLIC_NEXT_HOP__|$PUBLIC_NEXT_HOP|g" $NETPLAN_OUTPUT
    sed -i "s|__PRIVATE_IP_ADDRESS__|$PRIVATE_IP_ADDRESS|g" $NETPLAN_OUTPUT
    sed -i "s|__PRIVATE_IP_MASK__|$PRIVATE_IP_MASK|g" $NETPLAN_OUTPUT
    sed -i "s|__PRIVATE_NEXT_HOP__|$PRIVATE_NEXT_HOP|g" $NETPLAN_OUTPUT
    sed -i "s|__HOST_LINK_LOCAL_MANAGEMENT_IP__|$HOST_LINK_LOCAL_MANAGEMENT_IP|g" $NETPLAN_OUTPUT
    # 
    # install netplan and activacte
    #
    echo "Applying Netplan"
    cp $NETPLAN_OUTPUT $NETPLAN_ACTIVE
    netplan apply
}


function create_bigip_userdata {
    echo "Creating BIG-IP cloud-init user_data"
    BIGIP_CLOUDINIT_USERDATA_TEMPLATE="$script_dir/BIGIPUserDataTemplate.yaml"
    BIGIP_CLOUD_USERDATA="$script_dir/BIGIPUserData.yaml"
    cp $BIGIP_CLOUDINIT_USERDATA_TEMPLATE $BIGIP_CLOUD_USERDATA
    NETPLAN_ACTIVE=/etc/netplan/01-netcfg.yaml
    NETPLAN_BACKUP=/opt/F5Networks/onboarding/netplan-orginial.yaml
    # original copy needed
    if ! [ -e $NETPLAN_BACKUP ]; then
      cp $NETPLAN_ACTIVE $NETPLAN_BACKUP
    fi
    #
    # Read SSH key added to bare metal server and add to BIG-IP virtual edition
    #
    BIGIP_SSH_AUTH_KEY=$(cat /root/.ssh/authorized_keys | grep -Ev "^#|^$")
    #
    # Build cloudinit CI data ISO disk
    # 
    sed -i "s|__BIGIP_SSH_AUTH_KEY__|$BIGIP_SSH_AUTH_KEY|g" $BIGIP_CLOUD_USERDATA
    [[ -z "${TMOS_ADMIN_PASSWORD}" ]] && TMOS_ADMIN_PASSWORD='F5Networks!'
    sed -i "s|__TMOS_ADMIN_PASSWORD__|$TMOS_ADMIN_PASSWORD|g" $BIGIP_CLOUD_USERDATA
    [[ -z "${BIGIP_HOSTNAME}" ]] && BIGIP_HOSTNAME=$(hostname)
    BIGIP_TMOS_HOSTNAME=$BIGIP_HOSTNAME
    # Did we set this with an FQDN? Test for presence of '.'... if not take hostname.local
    if ! [[ $BIGIP_TMOS_HOSTNAME == *.* ]]; then 
        BIGIP_TMOS_HOSTNAME="$BIGIP_TMOS_HOSTNAME.local"
    fi
    sed -i "s|__BIGIP_HOSTNAME__|$BIGIP_TMOS_HOSTNAME|g" $BIGIP_CLOUD_USERDATA
    DNS_1=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][0])')
    DNS_2=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][1])')    
    sed -i "s|__DNS_1__|$DNS_1|g" $BIGIP_CLOUD_USERDATA
    sed -i "s|__DNS_2__|$DNS_2|g" $BIGIP_CLOUD_USERDATA
    third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
    third=$((16#$third))
    fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
    fourth=$((16#$fourth))
    HOST_LINK_LOCAL_MANAGEMENT_IP="169.254.$third.$fourth"
    fourth_next=$(($fourth + 1))
    [[ -z "${BIGIP_MANAGEMENT_IP}" ]] && BIGIP_MANAGEMENT_IP="169.254.$third.$fourth_next/16"
    sed -i "s|__BIGIP_MANAGEMENT_IP__|$BIGIP_MANAGEMENT_IP|g" $BIGIP_CLOUD_USERDATA
    [[ -z "${BIGIP_MANAGEMENT_NEXT_HOP}" ]] && BIGIP_MANAGEMENT_NEXT_HOP=$HOST_LINK_LOCAL_MANAGEMENT_IP
    sed -i "s|__BIGIP_MANAGEMENT_NEXT_HOP__|$BIGIP_MANAGEMENT_NEXT_HOP|g" $BIGIP_CLOUD_USERDATA
    [[ -z "${BIGIP_MANAGEMENT_MTU}" ]] && BIGIP_MANAGEMENT_MTU="1460"
    sed -i "s|__BIGIP_MANAGEMENT_MTU__|$BIGIP_MANAGEMENT_MTU|g" $BIGIP_CLOUD_USERDATA
    [[ -z "${BIGIP_INSTANCE_ID}" ]] && BIGIP_INSTANCE_ID="bigipinstance1"
    rm -rf "$script_dir/cidataiso"
    mkdir -p "$script_dir/cidataiso"
    echo "instance-id: {{ $BIGIPecho "Type=oneshot" >> $UNIT_FILE_INSTANCE_ID }}" >> "$script_dir/cidataiso/meta-data"
    echo "local-hostname: {{ $BIGIP_HOSTNAME }}" >> "$script_dir/cidataiso/meta-data"
    mv $BIGIP_CLOUD_USERDATA "$script_dir/cidataiso/user-data"
    pushd $script_dir/cidataiso
    mkisofs -V cidata -lJR -o output.iso meta-data user-data
    popd
    cp $script_dir/cidataiso/output.iso /opt/F5Networks/onboarding/BIGIP_USER_DATA.iso
}


function create_bigip_domain_xml {
    [[ -z "${BIGIP_VM_NAME}" ]] && BIGIP_VM_NAME="BIG-IP-Virtual-Edition"
    defined=$(virsh list --all | grep $BIGIP_VM_NAME | wc -l)
    if [ "$defined" -ne "1" ]; then    
        echo "Creating libvirt domain XML for BIG-IP virtual edition"
        lshw -class network -json > network_hardware.json
        ETH0VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["logicalname"])')
        ETH0VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
        ETH0VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f2)
        ETH0VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
        ETH0VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
        ETH1VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["logicalname"])')
        ETH1VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
        ETH1VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f2)
        ETH1VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
        ETH1VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
        ETH2VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["logicalname"])')
        ETH2VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
        ETH2VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f2)
        ETH2VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
        ETH2VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
        ETH3VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["logicalname"])')
        ETH3VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
        ETH3VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f2)
        ETH3VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
        ETH3VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
        BIGIP_DOMAIN_HOSTDEV_TEMPLATE="$script_dir/BIGIPDomainHOSTDEVTemplate.xml"
        BIGIP_DOMAIN_MACVTAP_TEMPLATE="$script_dir/BIGIPDomainMACVTAPTemplate.xml"
        BIGIP_DOMAIN_HOSTDEV="$script_dir/BIGIPDomainHOSTDEV.xml"
        BIGIP_DOMAIN_MACVTAP="$script_dir/BIGIPDomainMACVTAP.xml"
        BIGIP_IMAGE_FILE="$script_dir/BIGIPImages/BIG-IP-Instance-Disk.qcow2"
        BIGIP_CLOUDINIT_ISO=/opt/F5Networks/onboarding/BIGIP_USER_DATA.iso
        [[ -z "${BIGIP_VM_MEMORY}" ]] && BIGIP_VM_MEMORY="8388608"  
        [[ -z "${BIGIP_VM_VCPUS}" ]] && BIGIP_VM_VCPUS="4"
        cp $BIGIP_DOMAIN_HOSTDEV_TEMPLATE $BIGIP_DOMAIN_HOSTDEV
        cp $BIGIP_DOMAIN_MACVTAP_TEMPLATE $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__BIGIP_VM_NAME__|'${BIGIP_VM_NAME}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__BIGIP_VM_NAME__|'${BIGIP_VM_NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i "s|__BIGIP_VM_MEMORY__|$BIGIP_VM_MEMORY|g" $BIGIP_DOMAIN_HOSTDEV
        sed -i "s|__BIGIP_VM_MEMORY__|$BIGIP_VM_MEMORY|g" $BIGIP_DOMAIN_MACVTAP
        sed -i "s|__BIGIP_VM_VCPUS__|$BIGIP_VM_VCPUS|g" $BIGIP_DOMAIN_HOSTDEV
        sed -i "s|__BIGIP_VM_VCPUS__|$BIGIP_VM_VCPUS|g" $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__BIGIP_IMAGE_FILE__|'${BIGIP_IMAGE_FILE}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__BIGIP_IMAGE_FILE__|'${BIGIP_IMAGE_FILE}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__BIGIP_CLOUDINIT_ISO__|'${BIGIP_CLOUDINIT_ISO}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__BIGIP_CLOUDINIT_ISO__|'${BIGIP_CLOUDINIT_ISO}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH0VF1NAME__|'${ETH0VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH0VF2NAME__|'${ETH0VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH1VF1NAME__|'${ETH1VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH1VF2NAME__|'${ETH1VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH2VF1NAME__|'${ETH2VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH2VF2NAME__|'${ETH2VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH3VF1NAME__|'${ETH3VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH3VF2NAME__|'${ETH3VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
        sed -i 's|__ETH0VF1PCIDOMAIN__|'${ETH0VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF1PCIBUS__|'${ETH0VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF1PCISLOT__|'${ETH0VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF1PCIFUNC__|'${ETH0VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF1PCIDOMAIN__|'${ETH1VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF1PCIBUS__|'${ETH1VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF1PCISLOT__|'${ETH1VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF1PCIFUNC__|'${ETH1VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF1PCIDOMAIN__|'${ETH2VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF1PCIBUS__|'${ETH2VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF1PCISLOT__|'${ETH2VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF1PCIFUNC__|'${ETH2VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF1PCIDOMAIN__|'${ETH3VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF1PCIBUS__|'${ETH3VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF1PCISLOT__|'${ETH3VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF1PCIFUNC__|'${ETH3VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF2PCIDOMAIN__|'${ETH0VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF2PCIBUS__|'${ETH0VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF2PCISLOT__|'${ETH0VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH0VF2PCIFUNC__|'${ETH0VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF2PCIDOMAIN__|'${ETH1VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF2PCIBUS__|'${ETH1VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF2PCISLOT__|'${ETH1VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH1VF2PCIFUNC__|'${ETH1VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF2PCIDOMAIN__|'${ETH2VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF2PCIBUS__|'${ETH2VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF2PCISLOT__|'${ETH2VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH2VF2PCIFUNC__|'${ETH2VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF2PCIDOMAIN__|'${ETH3VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF2PCIBUS__|'${ETH3VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF2PCISLOT__|'${ETH3VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
        sed -i 's|__ETH3VF2PCIFUNC__|'${ETH3VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
        iommu_enabled=$(grep iommu /etc/default/grub | wc -l)
        if [ "$iommu_enabled" -ne "1" ]; then
          sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT.*$/GRUB_CMDLINE_LINUX_DEFAULT="intel_iommu=on iommu=pt numa_balancing=disable processor.max_cstate=0 isolcpus=6-9 nohz_full=6-9 rcu_nocbs=6-9 nosmt"/g' /etc/default/grub
          /usr/sbin/update-grub
          reboot
        fi
        virsh define $BIGIP_DOMAIN_HOSTDEV
    fi
}


function download_bigip_image {
  [[ -z "${BIGIP_IMAGE_DOWNLOAD_PATH}" ]] && BIGIP_IMAGE_DOWNLOAD_PATH='https://s3.us-east.cloud-object-storage.appdomain.cloud/f5-adc-bigip-17.5.0-0.0.15.all-1slot-031025001-us-east'
  [[ -z "${BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME}" ]] && BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME='BIGIP-17.5.0-0.0.15.ALL_1SLOT-031025001.qcow2'
  [[ -z "${BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5}" ]] && BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5="$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME.md5"
  if [ -f "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME" ] && [ -f "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5" ] && [ -f "$script_dir/BIGIPImages/BIG-IP-Instance-Disk.qcow2" ]; then
      echo "Existing BIG-IP virtual edition disk exists.. skipping download"
  else
    mkdir -p "$script_dir/BIGIPImages"
    image_url="$BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME"
    md5_url="$BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5"
    # Download with MD5 check
    download_md5=0
    image_md5=1
    while [ ! "$image_md5" == "$download_md5" ]; do
      rm -rf "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME"
      echo "Downloading $BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME..."
      wget --retry-connrefused --waitretry=1 --read-timeout=30 --timeout=15 -t 0 -nc $BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME -P "$script_dir/BIGIPImages"
      rm -rf "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5"
      echo "Downloading $BIGIP_IMAGE_DOWNLOAD_MD5/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5..."
      wget --retry-connrefused --waitretry=1 --read-timeout=30 --timeout=15 -t 0 -nc $BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5 -P "$script_dir/BIGIPImages"
      download_md5=$(md5sum "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME" | cut -d' ' -f1)
      image_md5=$(cat "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5")
    done
    cp "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME" "$script_dir/BIGIPImages/BIG-IP-Instance-Disk.qcow2"
  fi
}


function remove_port_forward_management_traffic {
    [[ -z "${MANAGEMENT_PORT_FORWARDS}" ]] && MANAGEMENT_PORT_FORWARDS=1
    if [ "$MANAGEMENT_PORT_FORWARDS" -eq "1" ]; then
        third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
        third=$((16#$third))
        fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
        fourth=$((16#$fourth))
        fourth_next=$(($fourth + 1))
        [[ -z "${BIGIP_MANAGEMENT_IP}" ]] && BIGIP_MANAGEMENT_IP="169.254.$third.$fourth_next"
        if [[ "$BIGIP_MANAGEMENT_IP" == */* ]]; then
            BIGIP_MANAGEMENT_IP=$(echo $BIGIP_MANAGEMENT_IP|cut -d'/' -f1)
        fi
        rules_present=$(iptables -t nat -L | grep DNAT | grep "dpt:2222 to:$BIGIP_MANAGEMENT_IP"|wc -l)
        while [ "$rules_present" -gt "0" ]; do
            # management bridge forwards
            iptables -t nat -D PREROUTING -i br0 -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443 > /dev/null 2>&1
            iptables -D FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT > /dev/null 2>&1
            iptables -t nat -D PREROUTING -i br0 -p tcp --dport 2222 -j DNAT --to $BIGIP_MANAGEMENT_IP:22 > /dev/null 2>&1
            iptables -D FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT > /dev/null 2>&1
            iptables -t nat -D POSTROUTING -j MASQUERADE > /dev/null 2>&1
            # management bridge forwards
            iptables -t nat -D PREROUTING -i bond1 -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443 > /dev/null 2>&1
            iptables -D FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT > /dev/null 2>&1
            iptables -t nat -D PREROUTING -i bond1 -p tcp --dport 2222 -j DNAT --to-destination $BIGIP_MANAGEMENT_IP:22 > /dev/null 2>&1
            iptables -D FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT > /dev/null 2>&1
            iptables -t nat -D POSTROUTING -j MASQUERADE > /dev/null 2>&1
            rules_present=$(iptables -t nat -L | grep DNAT | grep "dpt:2222 to:$BIGIP_MANAGEMENT_IP"|wc -l) > /dev/null 2>&1    
        done
    fi
}


function add_port_forward_management_traffic {
    [[ -z "${MANAGEMENT_PORT_FORWARDS}" ]] && MANAGEMENT_PORT_FORWARDS=1
    if [ "$MANAGEMENT_PORT_FORWARDS" -eq "1" ]; then
        third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
        third=$((16#$third))
        fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
        fourth=$((16#$fourth))
        fourth_next=$(($fourth + 1))
        [[ -z "${BIGIP_MANAGEMENT_IP}" ]] && BIGIP_MANAGEMENT_IP="169.254.$third.$fourth_next"
        if [[ "$BIGIP_MANAGEMENT_IP" == */* ]]; then
            BIGIP_MANAGEMENT_IP=$(echo $BIGIP_MANAGEMENT_IP|cut -d'/' -f1)
        fi
        # remove so we don't add multiple times
        remove_port_forward_management_traffic
        # managment bridge forwards
        iptables -t nat -I PREROUTING -i br0  -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443
        iptables -I FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT
        iptables -t nat -I PREROUTING -i br0  -p tcp --dport 2222 -j DNAT --to $BIGIP_MANAGEMENT_IP:22
        iptables -I FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT
        iptables -t nat -I POSTROUTING -j MASQUERADE
        # management bridge 
        iptables -t nat -I PREROUTING -i bond1 -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443
        iptables -I FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT
        iptables -t nat -I PREROUTING -i bond1 -p tcp --dport 2222 -j DNAT --to $BIGIP_MANAGEMENT_IP:22
        iptables -A FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT
        iptables -t nat -I POSTROUTING -j MASQUERADE
    fi
}


function start_vm {
    ip link set eth0 vf 0 trust on
    ip link set eth1 vf 0 trust on
    ip link set eth2 vf 0 trust on
    ip link set eth3 vf 0 trust on
    ip link set eth0 vf 0 spookchk off
    ip link set eth0 vf 0 spoofchk off
    ip link set eth1 vf 0 spoofchk off
    ip link set eth2 vf 0 spoofchk off
    ip link set eth3 vf 0 spoofchk off
    add_port_forward_management_traffic
    [[ -z "${BIGIP_VM_NAME}" ]] && BIGIP_VM_NAME="BIG-IP-Virtual-Edition"
    running=$(virsh list --all | grep $BIGIP_VM_NAME | grep 'running' | wc -l)
    shutoff=$(virsh list --all | grep $BIGIP_VM_NAME | grep 'shut off' | wc -l)
    if [ "$running" -eq "1" ]; then
        echo "$BIGIP_VM_NAME is already running.."
    else
        virsh start $BIGIP_VM_NAME
    fi
}


function shutdown_vm {
    remove_port_forward_management_traffic
    [[ -z "${BIGIP_VM_NAME}" ]] && BIGIP_VM_NAME="BIG-IP-Virtual-Edition"
    shutoff=$(virsh list --all | grep $BIGIP_VM_NAME | grep 'shut off' | wc -l)
    if [ "$shutoff" -eq "1" ]; then
        echo "$BIGIP_VM_NAME is already shutdown.."
    else
        virsh shutdown $BIGIP_VM_NAME
    fi
}


function create_systemd_unit_file {
    UNIT_FILE="/etc/systemd/system/bigip-virtual-edition.service"
    echo "[Unit]" > $UNIT_FILE
    echo "Description=BIG-IP virtual edition service" >> $UNIT_FILE
    echo "After=network.target" >> $UNIT_FILE
    echo "StartLimitIntervalSec=0" >> $UNIT_FILE
    echo "" >> $UNIT_FILE
    echo "[Service]" >> $UNIT_FILE
    echo "WorkingDirectory=/opt/F5Networks/onboarding" >> $UNIT_FILE
    echo "Type=oneshot" >> $UNIT_FILE
    echo "User=root" >> $UNIT_FILE
    echo "ExecStart=/opt/F5Networks/onboarding/start" >> $UNIT_FILE
    echo "ExecStop=/opt/F5Networks/onboarding/stop" >> $UNIT_FILE
    echo "RemainAfterExit=1" >> $UNIT_FILE
    echo "" >> $UNIT_FILE
    echo "[Install]" >> $UNIT_FILE
    echo "WantedBy=multi-user.target" >> $UNIT_FILE
}


function enable_systemd_service {
    systemctl enable bigip-virtual-edition.service
}


function disable_systemd_service {
    systemctl disable bigip-virtual-edition.service
}


function start_systemd_service {
    systemctl start bigip-virtual-edition.service
}


function stop_systemd_service {
    systemctl stop bigip-virtual-edition.service
}


function start {
  assure_packages 
  download_bigip_image
  create_netplan
  create_bigip_userdata
  create_bigip_domain_xml
  start_vm
}


function stop {
  shutdown_vm
}