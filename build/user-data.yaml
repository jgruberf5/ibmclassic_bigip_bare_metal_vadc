#cloud-config
package_update: true
package_upgrade: true
packages:
  - bridge-utils
  - cpu-checker
  - libvirt-clients
  - libvirt-daemon
  - libvirt-daemon-system
  - qemu
  - qemu-kvm
  - genisoimage
  - ipcalc
bootcmd:
  - [ cloud-init-per, once, mkdir, -m, 0755, -p, '/opt/F5Networks/onboarding' ]
write_files:
  - path: /opt/F5Networks/onboarding/installenv
    permissions: 0755
    content: |
      #!/bin/bash
      
      export script_dir=/opt/F5Networks/onboarding
      
      
      if [ -f "/etc/bigip" ]; then
          source /etc/bigip
      fi
      
      
      function set_permissions {
          chmod +x $script_dir/scripts/start
          chmod +x $script_dir/scripts/stop
      }
      
      
      function assure_packages {
        echo "Installing hypervisor and qemu agent requirements"
        apt update
        for pkg in bridge-utils cpu-checker libvirt-clients libvirt-daemon libvirt-daemon-system qemu qemu-kvm genisoimage; do
            installed=$(dpkg-query -W --showformat='${Status}\n' $pkg|grep "install ok installed"|wc -l)
            if [ "$installed" -ne "1" ]; then
                apt install -y $pkg
            fi 
        done
      }
      
      
      function create_netplan {
          echo "Creating BIG-IP virtual edition management access and activating SR-IOV virtual functions"
          
          NETPLAN_ACTIVE=/etc/netplan/01-netcfg.yaml
          NETPLAN_BACKUP=/opt/F5Networks/onboarding/netplan-orginial.yaml
          # original copy needed
          if ! [ -e $NETPLAN_BACKUP ]; then
            cp $NETPLAN_ACTIVE $NETPLAN_BACKUP
          fi
          
          # Read IP from bond0 (private) and populate BIG-IP netplan YAML to move IP address to bridge with BIG-IP management port
          #
          # This method uses linux network settings - assumes networking is up
          #PRIVATE_INTERFACE=bond0
          #PRIVATE_IP_ADDRESS=$(ip addr show $PRIVATE_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
          #PRIVATE_IP_MASK=$(ip addr show $PRIVATE_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f2)
          #PRIVATE_NEXT_HOP=$(ip route show 10.0.0.0/8 | awk '{print $3}')
          #
          # This method uses the existing Ubuntu netplan YAML for IBM Classic bare metal servers
          # If the default netplan changes, this will need to be adjusted
          #
          # private ip addres = networks.bonds.bond0.address.0
          # private ip next hop = networks.bonds.bond0.routes.0.via
          #
          PRIVATE_IP_ADDRESS=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["addresses"][0])'| cut -d'/' -f1)
          PRIVATE_IP_MASK=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["addresses"][0])'| cut -d'/' -f2)
          PRIVATE_NEXT_HOP=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["routes"][0]["via"])')
      
          # Read IP from bond1 (public) and populate BIG-IP netplan YAML
          #
          # This method uses linux network settings - assumes networking is up
          #PUBLIC_INTERFACE=bond1
          #PUBLIC_IP_ADDRESS=$(ip addr show $PUBLIC_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
          #PUBLIC_IP_MASK=$(ip addr show $PUBLIC_INTERFACE | grep "inet " | awk '{print $2}' | cut -d'/' -f2)
          #PUBLIC_NEXT_HOP=$(ip route show default | awk '{print $3}')
          #
          # This method uses the existing Ubuntu netplan YAML for IBM Classic bare metal servers
          # If the default netplan changes, this will need to be adjusted
          #
          # public ip addres = networks.bonds.bond1.address.0
          # public ip next hop = networks.bonds.bond1.gateway4
          #
          PUBLIC_IP_ADDRESS=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond1"]["addresses"][0])' | cut -d'/' -f1)
          PUBLIC_IP_MASK=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond1"]["addresses"][0])' | cut -d'/' -f2)
          PUBLIC_NEXT_HOP=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond1"]["gateway4"])')
          #
          # Read DNS server for private DNS servers
          #
          # This method uses what is statically set in the linux resolver config - assumes netplan has created the config
          #DNS_1=$(cat /etc/resolv.conf | grep -m 1 nameserver | awk '{ print $2 }')
          #DNS_2=$(cat /etc/resolv.conf | grep -m 2 nameserver | tail -n1 | awk '{ print $2 }')
          #
          # This method uses the existing Ubuntu netplan YAML for IBM Classic bare metal servers
          # If the default netplan changes, this will need to be adjusted
          #
          export DNS_1=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][0])')
          export DNS_2=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][1])')
          #
          NETPLAN_TEMPLATE="$script_dir/netplan_template.yaml"
          NETPLAN_OUTPUT="$script_dir/netplan.yaml"
      
          third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
          third=$((16#$third))
          fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
          fourth=$((16#$fourth))
          HOST_LINK_LOCAL_MANAGEMENT_IP="169.254.$third.$fourth/16"
      
          cp $NETPLAN_TEMPLATE $NETPLAN_OUTPUT
          sed -i "s|__DNS_1__|$DNS_1|g" $NETPLAN_OUTPUT
          sed -i "s|__DNS_2__|$DNS_2|g" $NETPLAN_OUTPUT
          sed -i "s|__PUBLIC_IP_ADDRESS__|$PUBLIC_IP_ADDRESS|g" $NETPLAN_OUTPUT
          sed -i "s|__PUBLIC_IP_MASK__|$PUBLIC_IP_MASK|g" $NETPLAN_OUTPUT
          sed -i "s|__PUBLIC_NEXT_HOP__|$PUBLIC_NEXT_HOP|g" $NETPLAN_OUTPUT
          sed -i "s|__PRIVATE_IP_ADDRESS__|$PRIVATE_IP_ADDRESS|g" $NETPLAN_OUTPUT
          sed -i "s|__PRIVATE_IP_MASK__|$PRIVATE_IP_MASK|g" $NETPLAN_OUTPUT
          sed -i "s|__PRIVATE_NEXT_HOP__|$PRIVATE_NEXT_HOP|g" $NETPLAN_OUTPUT
          sed -i "s|__HOST_LINK_LOCAL_MANAGEMENT_IP__|$HOST_LINK_LOCAL_MANAGEMENT_IP|g" $NETPLAN_OUTPUT
          # 
          # install netplan and activacte
          #
          echo "Applying Netplan"
          cp $NETPLAN_OUTPUT $NETPLAN_ACTIVE
          netplan apply
      }
      
      
      function create_bigip_userdata {
          echo "Creating BIG-IP cloud-init user_data"
          BIGIP_CLOUDINIT_USERDATA_TEMPLATE="$script_dir/BIGIPUserDataTemplate.yaml"
          BIGIP_CLOUD_USERDATA="$script_dir/BIGIPUserData.yaml"
          cp $BIGIP_CLOUDINIT_USERDATA_TEMPLATE $BIGIP_CLOUD_USERDATA
          NETPLAN_ACTIVE=/etc/netplan/01-netcfg.yaml
          NETPLAN_BACKUP=/opt/F5Networks/onboarding/netplan-orginial.yaml
          # original copy needed
          if ! [ -e $NETPLAN_BACKUP ]; then
            cp $NETPLAN_ACTIVE $NETPLAN_BACKUP
          fi
          #
          # Read SSH key added to bare metal server and add to BIG-IP virtual edition
          #
          BIGIP_SSH_AUTH_KEY=$(cat /root/.ssh/authorized_keys | grep -Ev "^#|^$")
          #
          # Build cloudinit CI data ISO disk
          # 
          sed -i "s|__BIGIP_SSH_AUTH_KEY__|$BIGIP_SSH_AUTH_KEY|g" $BIGIP_CLOUD_USERDATA
          [[ -z "${TMOS_ADMIN_PASSWORD}" ]] && TMOS_ADMIN_PASSWORD='F5Networks!'
          sed -i "s|__TMOS_ADMIN_PASSWORD__|$TMOS_ADMIN_PASSWORD|g" $BIGIP_CLOUD_USERDATA
          [[ -z "${BIGIP_HOSTNAME}" ]] && BIGIP_HOSTNAME=$(hostname)
          BIGIP_TMOS_HOSTNAME=$BIGIP_HOSTNAME
          # Did we set this with an FQDN? Test for presence of '.'... if not take hostname.local
          if ! [[ $BIGIP_TMOS_HOSTNAME == *.* ]]; then 
              BIGIP_TMOS_HOSTNAME="$BIGIP_TMOS_HOSTNAME.local"
          fi
          sed -i "s|__BIGIP_HOSTNAME__|$BIGIP_TMOS_HOSTNAME|g" $BIGIP_CLOUD_USERDATA
          DNS_1=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][0])')
          DNS_2=$(cat $NETPLAN_BACKUP | python3 -c 'import json, sys, yaml ; y = yaml.safe_load(sys.stdin.read()) ; print(y["network"]["bonds"]["bond0"]["nameservers"]["addresses"][1])')    
          sed -i "s|__DNS_1__|$DNS_1|g" $BIGIP_CLOUD_USERDATA
          sed -i "s|__DNS_2__|$DNS_2|g" $BIGIP_CLOUD_USERDATA
          third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
          third=$((16#$third))
          fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
          fourth=$((16#$fourth))
          HOST_LINK_LOCAL_MANAGEMENT_IP="169.254.$third.$fourth"
          fourth_next=$(($fourth + 1))
          [[ -z "${BIGIP_MANAGEMENT_IP}" ]] && BIGIP_MANAGEMENT_IP="169.254.$third.$fourth_next/16"
          sed -i "s|__BIGIP_MANAGEMENT_IP__|$BIGIP_MANAGEMENT_IP|g" $BIGIP_CLOUD_USERDATA
          [[ -z "${BIGIP_MANAGEMENT_NEXT_HOP}" ]] && BIGIP_MANAGEMENT_NEXT_HOP=$HOST_LINK_LOCAL_MANAGEMENT_IP
          sed -i "s|__BIGIP_MANAGEMENT_NEXT_HOP__|$BIGIP_MANAGEMENT_NEXT_HOP|g" $BIGIP_CLOUD_USERDATA
          [[ -z "${BIGIP_MANAGEMENT_MTU}" ]] && BIGIP_MANAGEMENT_MTU="1460"
          sed -i "s|__BIGIP_MANAGEMENT_MTU__|$BIGIP_MANAGEMENT_MTU|g" $BIGIP_CLOUD_USERDATA
          [[ -z "${BIGIP_INSTANCE_ID}" ]] && BIGIP_INSTANCE_ID="bigipinstance1"
          rm -rf "$script_dir/cidataiso"
          mkdir -p "$script_dir/cidataiso"
          echo "instance-id: {{ $BIGIPecho "Type=oneshot" >> $UNIT_FILE_INSTANCE_ID }}" >> "$script_dir/cidataiso/meta-data"
          echo "local-hostname: {{ $BIGIP_HOSTNAME }}" >> "$script_dir/cidataiso/meta-data"
          mv $BIGIP_CLOUD_USERDATA "$script_dir/cidataiso/user-data"
          pushd $script_dir/cidataiso
          mkisofs -V cidata -lJR -o output.iso meta-data user-data
          popd
          cp $script_dir/cidataiso/output.iso /opt/F5Networks/onboarding/BIGIP_USER_DATA.iso
      }
      
      
      function create_bigip_domain_xml {
          [[ -z "${BIGIP_VM_NAME}" ]] && BIGIP_VM_NAME="BIG-IP-Virtual-Edition"
          defined=$(virsh list --all | grep $BIGIP_VM_NAME | wc -l)
          if [ "$defined" -ne "1" ]; then    
              echo "Creating libvirt domain XML for BIG-IP virtual edition"
              lshw -class network -json > network_hardware.json
              ETH0VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["logicalname"])')
              ETH0VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
              ETH0VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f2)
              ETH0VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
              ETH0VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[4]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
              ETH1VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["logicalname"])')
              ETH1VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
              ETH1VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f2)
              ETH1VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
              ETH1VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[5]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
              ETH2VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["logicalname"])')
              ETH2VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
              ETH2VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f2)
              ETH2VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
              ETH2VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[6]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
              ETH3VF1NAME=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["logicalname"])')
              ETH3VF1PCIDOMAIN=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f1 | cut -d'@' -f2)
              ETH3VF1PCIBUS=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f2)
              ETH3VF1PCISLOT=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f3 | cut -d'.' -f1)
              ETH3VF1PCIFUNC=$(cat network_hardware.json | python3 -c 'import sys, json ; j = json.load(sys.stdin) ; print(j[7]["businfo"])' | cut -d':' -f3 | cut -d'.' -f2)
              BIGIP_DOMAIN_HOSTDEV_TEMPLATE="$script_dir/BIGIPDomainHOSTDEVTemplate.xml"
              BIGIP_DOMAIN_MACVTAP_TEMPLATE="$script_dir/BIGIPDomainMACVTAPTemplate.xml"
              BIGIP_DOMAIN_HOSTDEV="$script_dir/BIGIPDomainHOSTDEV.xml"
              BIGIP_DOMAIN_MACVTAP="$script_dir/BIGIPDomainMACVTAP.xml"
              BIGIP_IMAGE_FILE="$script_dir/BIGIPImages/BIG-IP-Instance-Disk.qcow2"
              BIGIP_CLOUDINIT_ISO=/opt/F5Networks/onboarding/BIGIP_USER_DATA.iso
              [[ -z "${BIGIP_VM_MEMORY}" ]] && BIGIP_VM_MEMORY="4194304"  
              [[ -z "${BIGIP_VM_VCPUS}" ]] && BIGIP_VM_VCPUS="2"   
              cp $BIGIP_DOMAIN_HOSTDEV_TEMPLATE $BIGIP_DOMAIN_HOSTDEV
              cp $BIGIP_DOMAIN_MACVTAP_TEMPLATE $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__BIGIP_VM_NAME__|'${BIGIP_VM_NAME}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__BIGIP_VM_NAME__|'${BIGIP_VM_NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i "s|__BIGIP_VM_MEMORY__|$BIGIP_VM_MEMORY|g" $BIGIP_DOMAIN_HOSTDEV
              sed -i "s|__BIGIP_VM_MEMORY__|$BIGIP_VM_MEMORY|g" $BIGIP_DOMAIN_MACVTAP
              sed -i "s|__BIGIP_VM_VCPUS__|$BIGIP_VM_VCPUS|g" $BIGIP_DOMAIN_HOSTDEV
              sed -i "s|__BIGIP_VM_VCPUS__|$BIGIP_VM_VCPUS|g" $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__BIGIP_IMAGE_FILE__|'${BIGIP_IMAGE_FILE}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__BIGIP_IMAGE_FILE__|'${BIGIP_IMAGE_FILE}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__BIGIP_CLOUDINIT_ISO__|'${BIGIP_CLOUDINIT_ISO}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__BIGIP_CLOUDINIT_ISO__|'${BIGIP_CLOUDINIT_ISO}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH0VF1NAME__|'${ETH0VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH0VF2NAME__|'${ETH0VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH1VF1NAME__|'${ETH1VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH1VF2NAME__|'${ETH1VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH2VF1NAME__|'${ETH2VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH2VF2NAME__|'${ETH2VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH3VF1NAME__|'${ETH3VF1NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH3VF2NAME__|'${ETH3VF2NAME}'|g' $BIGIP_DOMAIN_MACVTAP
              sed -i 's|__ETH0VF1PCIDOMAIN__|'${ETH0VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF1PCIBUS__|'${ETH0VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF1PCISLOT__|'${ETH0VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF1PCIFUNC__|'${ETH0VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF1PCIDOMAIN__|'${ETH1VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF1PCIBUS__|'${ETH1VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF1PCISLOT__|'${ETH1VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF1PCIFUNC__|'${ETH1VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF1PCIDOMAIN__|'${ETH2VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF1PCIBUS__|'${ETH2VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF1PCISLOT__|'${ETH2VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF1PCIFUNC__|'${ETH2VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF1PCIDOMAIN__|'${ETH3VF1PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF1PCIBUS__|'${ETH3VF1PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF1PCISLOT__|'${ETH3VF1PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF1PCIFUNC__|'${ETH3VF1PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF2PCIDOMAIN__|'${ETH0VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF2PCIBUS__|'${ETH0VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF2PCISLOT__|'${ETH0VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH0VF2PCIFUNC__|'${ETH0VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF2PCIDOMAIN__|'${ETH1VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF2PCIBUS__|'${ETH1VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF2PCISLOT__|'${ETH1VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH1VF2PCIFUNC__|'${ETH1VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF2PCIDOMAIN__|'${ETH2VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF2PCIBUS__|'${ETH2VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF2PCISLOT__|'${ETH2VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH2VF2PCIFUNC__|'${ETH2VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF2PCIDOMAIN__|'${ETH3VF2PCIDOMAIN}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF2PCIBUS__|'${ETH3VF2PCIBUS}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF2PCISLOT__|'${ETH3VF2PCISLOT}'|g' $BIGIP_DOMAIN_HOSTDEV
              sed -i 's|__ETH3VF2PCIFUNC__|'${ETH3VF2PCIFUNC}'|g' $BIGIP_DOMAIN_HOSTDEV
              iommu_enabled=$(grep iommu /etc/default/grub | wc -l)
              if [ "$iommu_enabled" -ne "1" ]; then
                sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT.*$/GRUB_CMDLINE_LINUX_DEFAULT="intel_iommu=on iommu=pt numa_balancing=disable processor.max_cstate=0 isolcpus=11-31,43-63 nohz_full=11-31,43-63 rcu_nocbs=11-31,43-63 nosmt"/g' /etc/default/grub
                /usr/sbin/update-grub
                reboot
              fi
              virsh define $BIGIP_DOMAIN_HOSTDEV
          fi
      }
      
      
      function download_bigip_image {
        [[ -z "${BIGIP_IMAGE_DOWNLOAD_PATH}" ]] && BIGIP_IMAGE_DOWNLOAD_PATH='https://s3.us-east.cloud-object-storage.appdomain.cloud/f5-adc-bigip-17.5.0-0.0.15.all-1slot-031025001-us-east'
        [[ -z "${BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME}" ]] && BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME='BIGIP-17.5.0-0.0.15.ALL_1SLOT-031025001.qcow2'
        [[ -z "${BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5}" ]] && BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5="$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME.md5"
        if [ -f "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME" ] && [ -f "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5" ] && [ -f "$script_dir/BIGIPImages/BIG-IP-Instance-Disk.qcow2" ]; then
            echo "Existing BIG-IP virtual edition disk exists.. skipping download"
        else
          mkdir -p "$script_dir/BIGIPImages"
          image_url="$BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME"
          md5_url="$BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5"
          # Download with MD5 check
          download_md5=0
          image_md5=1
          while [ ! "$image_md5" == "$download_md5" ]; do
            rm -rf "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME"
            echo "Downloading $BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME..."
            wget --retry-connrefused --waitretry=1 --read-timeout=30 --timeout=15 -t 0 -nc $BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME -P "$script_dir/BIGIPImages"
            rm -rf "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5"
            echo "Downloading $BIGIP_IMAGE_DOWNLOAD_MD5/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5..."
            wget --retry-connrefused --waitretry=1 --read-timeout=30 --timeout=15 -t 0 -nc $BIGIP_IMAGE_DOWNLOAD_PATH/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5 -P "$script_dir/BIGIPImages"
            download_md5=$(md5sum "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME" | cut -d' ' -f1)
            image_md5=$(cat "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_MD5")
          done
          cp "$script_dir/BIGIPImages/$BIGIP_IMAGE_DOWNLOAD_IMAGE_NAME" "$script_dir/BIGIPImages/BIG-IP-Instance-Disk.qcow2"
        fi
      }
      
      
      function remove_port_forward_management_traffic {
          [[ -z "${MANAGEMENT_PORT_FORWARDS}" ]] && MANAGEMENT_PORT_FORWARDS=1
          if [ "$MANAGEMENT_PORT_FORWARDS" -eq "1" ]; then
              third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
              third=$((16#$third))
              fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
              fourth=$((16#$fourth))
              fourth_next=$(($fourth + 1))
              [[ -z "${BIGIP_MANAGEMENT_IP}" ]] && BIGIP_MANAGEMENT_IP="169.254.$third.$fourth_next"
              if [[ "$BIGIP_MANAGEMENT_IP" == */* ]]; then
                  BIGIP_MANAGEMENT_IP=$(echo $BIGIP_MANAGEMENT_IP|cut -d'/' -f1)
              fi
              rules_present=$(iptables -t nat -L | grep DNAT | grep "dpt:2222 to:$BIGIP_MANAGEMENT_IP"|wc -l)
              while [ "$rules_present" -gt "0" ]; do
                  # management bridge forwards
                  iptables -t nat -D PREROUTING -i br0 -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443 > /dev/null 2>&1
                  iptables -D FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT > /dev/null 2>&1
                  iptables -t nat -D PREROUTING -i br0 -p tcp --dport 2222 -j DNAT --to $BIGIP_MANAGEMENT_IP:22 > /dev/null 2>&1
                  iptables -D FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT > /dev/null 2>&1
                  iptables -t nat -D POSTROUTING -j MASQUERADE > /dev/null 2>&1
                  # management bridge forwards
                  iptables -t nat -D PREROUTING -i bond1 -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443 > /dev/null 2>&1
                  iptables -D FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT > /dev/null 2>&1
                  iptables -t nat -D PREROUTING -i bond1 -p tcp --dport 2222 -j DNAT --to-destination $BIGIP_MANAGEMENT_IP:22 > /dev/null 2>&1
                  iptables -D FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT > /dev/null 2>&1
                  iptables -t nat -D POSTROUTING -j MASQUERADE > /dev/null 2>&1
                  rules_present=$(iptables -t nat -L | grep DNAT | grep "dpt:2222 to:$BIGIP_MANAGEMENT_IP"|wc -l) > /dev/null 2>&1    
              done
          fi
      }
      
      
      function add_port_forward_management_traffic {
          [[ -z "${MANAGEMENT_PORT_FORWARDS}" ]] && MANAGEMENT_PORT_FORWARDS=1
          if [ "$MANAGEMENT_PORT_FORWARDS" -eq "1" ]; then
              third=$(cat /sys/class/net/bond0/address | cut -d':' -f5)
              third=$((16#$third))
              fourth=$(cat /sys/class/net/bond0/address | cut -d':' -f6)
              fourth=$((16#$fourth))
              fourth_next=$(($fourth + 1))
              [[ -z "${BIGIP_MANAGEMENT_IP}" ]] && BIGIP_MANAGEMENT_IP="169.254.$third.$fourth_next"
              if [[ "$BIGIP_MANAGEMENT_IP" == */* ]]; then
                  BIGIP_MANAGEMENT_IP=$(echo $BIGIP_MANAGEMENT_IP|cut -d'/' -f1)
              fi
              # remove so we don't add multiple times
              remove_port_forward_management_traffic
              # managment bridge forwards
              iptables -t nat -I PREROUTING -i br0  -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443
              iptables -I FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT
              iptables -t nat -I PREROUTING -i br0  -p tcp --dport 2222 -j DNAT --to $BIGIP_MANAGEMENT_IP:22
              iptables -I FORWARD -i br0 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT
              iptables -t nat -I POSTROUTING -j MASQUERADE
              # management bridge 
              iptables -t nat -I PREROUTING -i bond1 -p tcp --dport 443 -j DNAT --to $BIGIP_MANAGEMENT_IP:443
              iptables -I FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 443 -j ACCEPT
              iptables -t nat -I PREROUTING -i bond1 -p tcp --dport 2222 -j DNAT --to $BIGIP_MANAGEMENT_IP:22
              iptables -A FORWARD -i bond1 -p tcp -d $BIGIP_MANAGEMENT_IP --dport 22 -j ACCEPT
              iptables -t nat -I POSTROUTING -j MASQUERADE
          fi
      }
      
      
      function start_vm {
          add_port_forward_management_traffic
          [[ -z "${BIGIP_VM_NAME}" ]] && BIGIP_VM_NAME="BIG-IP-Virtual-Edition"
          running=$(virsh list --all | grep $BIGIP_VM_NAME | grep 'running' | wc -l)
          shutoff=$(virsh list --all | grep $BIGIP_VM_NAME | grep 'shut off' | wc -l)
          if [ "$running" -eq "1" ]; then
              echo "$BIGIP_VM_NAME is already running.."
          else
              virsh start $BIGIP_VM_NAME
          fi
      }
      
      
      function shutdown_vm {
          remove_port_forward_management_traffic
          [[ -z "${BIGIP_VM_NAME}" ]] && BIGIP_VM_NAME="BIG-IP-Virtual-Edition"
          shutoff=$(virsh list --all | grep $BIGIP_VM_NAME | grep 'shut off' | wc -l)
          if [ "$shutoff" -eq "1" ]; then
              echo "$BIGIP_VM_NAME is already shutdown.."
          else
              virsh shutdown $BIGIP_VM_NAME
          fi
      }
      
      
      function create_systemd_unit_file {
          UNIT_FILE="/etc/systemd/system/bigip-virtual-edition.service"
          echo "[Unit]" > $UNIT_FILE
          echo "Description=BIG-IP virtual edition service" >> $UNIT_FILE
          echo "After=network.target" >> $UNIT_FILE
          echo "StartLimitIntervalSec=0" >> $UNIT_FILE
          echo "" >> $UNIT_FILE
          echo "[Service]" >> $UNIT_FILE
          echo "WorkingDirectory=/opt/F5Networks/onboarding" >> $UNIT_FILE
          echo "Type=oneshot" >> $UNIT_FILE
          echo "User=root" >> $UNIT_FILE
          echo "ExecStart=/opt/F5Networks/onboarding/start" >> $UNIT_FILE
          echo "ExecStop=/opt/F5Networks/onboarding/stop" >> $UNIT_FILE
          echo "RemainAfterExit=1" >> $UNIT_FILE
          echo "" >> $UNIT_FILE
          echo "[Install]" >> $UNIT_FILE
          echo "WantedBy=multi-user.target" >> $UNIT_FILE
      }
      
      
      function enable_systemd_service {
          systemctl enable bigip-virtual-edition.service
      }
      
      
      function disable_systemd_service {
          systemctl disable bigip-virtual-edition.service
      }
      
      
      function start_systemd_service {
          systemctl start bigip-virtual-edition.service
      }
      
      
      function stop_systemd_service {
          systemctl stop bigip-virtual-edition.service
      }
      
      
      function start {
        assure_packages 
        download_bigip_image
        create_netplan
        create_bigip_userdata
        create_bigip_domain_xml
        start_vm
      }
      
      
      function stop {
        shutdown_vm
  - path: /opt/F5Networks/onboarding/onboarding.sh
    permissions: 0755
    content: |
      #!/bin/bash
      
      export script_dir=/opt/F5Networks/onboarding
      
      # Source the installenv file
      if [ -f "$script_dir/installenv" ]; then
        source "$script_dir/installenv"
      else
        echo "Error: installenv file not found in $script_dir"
        exit 1
      fi
      
      set_permissions
      create_systemd_unit_file
      enable_systemd_service
  - path: /opt/F5Networks/onboarding/start
    permissions: 0755
    content: |
      #!/bin/bash
      
      export script_dir=/opt/F5Networks/onboarding
      
      # Source the installenv file
      if [ -f "$script_dir/installenv" ]; then
        source "$script_dir/installenv"
      else
        echo "Error: installenv file not found in $script_dir"
        exit 1
      fi
      
  - path: /opt/F5Networks/onboarding/stop
    permissions: 0755
    content: |
      #!/bin/bash
      
      export script_dir=/opt/F5Networks/onboarding
      
      # Source the installenv file
      if [ -f "$script_dir/installenv" ]; then
        source "$script_dir/installenv"
      else
        echo "Error: installenv file not found in $script_dir"
        exit 1
      fi
      
  - path: /opt/F5Networks/onboarding/BIGIPDomainHOSTDEVTemplate.xml
    permissions: 0644
    content: |
      <domain type="kvm">
          <name>__BIGIP_VM_NAME__</name>
          <metadata>
            <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0">
              <libosinfo:os id="http://libosinfo.org/linux/2022"/>
            </libosinfo:libosinfo>
          </metadata>
          <memory>__BIGIP_VM_MEMORY__</memory>
          <currentMemory>__BIGIP_VM_MEMORY__</currentMemory>
          <vcpu>__BIGIP_VM_VCPUS__</vcpu>
          <os>
            <type arch="x86_64" machine="q35">hvm</type>
            <boot dev="hd"/>
          </os>
          <features>
            <acpi/>
            <apic/>
            <vmport state="off"/>
          </features>
          <cpu mode="host-model"/>
          <clock offset="utc">
            <timer name="rtc" tickpolicy="catchup"/>
            <timer name="pit" tickpolicy="delay"/>
            <timer name="hpet" present="no"/>
          </clock>
          <pm>
            <suspend-to-mem enabled="no"/>
            <suspend-to-disk enabled="no"/>
          </pm>
          <devices>
            <emulator>/usr/bin/qemu-system-x86_64</emulator>
            <disk type="file" device="disk">
              <driver name="qemu" type="qcow2"/>
              <source file="__BIGIP_IMAGE_FILE__"/>
              <target dev="vda" bus="virtio"/>
            </disk>
            <disk type="file" device="cdrom">
              <driver name="qemu" type="raw"/>
              <source file="__BIGIP_CLOUDINIT_ISO__"/>
              <target dev="sda" bus="sata"/>
              <readonly/>
            </disk>
            <controller type="usb" model="qemu-xhci" ports="15"/>
            <controller type="pci" model="pcie-root"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <interface type="bridge">
              <source bridge="br0"/>
              <model type="virtio"/>
            </interface>
            <!-- PCI Passthrough for VF eth0vf0  pci@__ETH0VF1PCIDOMAIN__:__ETH0VF1PCIBUF__:__ETH0VF1PCISLOT__.__ETH0VF1PCIFUNC__ -->
            <interface type='hostdev' managed='yes'>
            <source>
                <address type='pci' domain='0x__ETH0VF1PCIDOMAIN__' bus='0x__ETH0VF1PCIBUS__' slot='0x__ETH0VF1PCISLOT__' function='0x__ETH0VF1PCIFUNC__'/>
            </source>
            <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
            </interface>
            <!-- PCI Passthrough for VF eth1vf0  pci@__ETH1VF1PCIDOMAIN__:__ETH1VF1PCIBUF__:__ETH1VF1PCISLOT__.__ETH1VF1PCIFUNC__ -->
            <interface type='hostdev' managed='yes'>
            <source>
                <address type='pci' domain='0x__ETH2VF1PCIDOMAIN__' bus='0x__ETH2VF1PCIBUS__' slot='0x__ETH2VF1PCISLOT__' function='0x__ETH2VF1PCIFUNC__'/>
            </source>
            <address type='pci' domain='0x0000' bus='0x00' slot='0x06' function='0x0'/>
            </interface>
            <!-- PCI Passthrough for VF eth2vf0  pci@__ETH2VF1PCIDOMAIN__:__ETH2VF1PCIBUF__:__ETH2VF1PCISLOT__.__ETH2VF1PCIFUNC__ -->
            <interface type='hostdev' managed='yes'>
            <source>
                <address type='pci' domain='0x__ETH1VF1PCIDOMAIN__' bus='0x__ETH1VF1PCIBUS__' slot='0x__ETH1VF1PCISLOT__' function='0x__ETH1VF1PCIFUNC__'/>
            </source>
            <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
            </interface>
            <!-- PCI Passthrough for VF eth3vf0  pci@__ETH0VF3PCIDOMAIN__:__ETH0VF3PCIBUF__:__ETH0VF3PCISLOT__.__ETH0VF3PCIFUNC__ -->
            <interface type='hostdev' managed='yes'>
            <source>
                <address type='pci' domain='0x__ETH3VF1PCIDOMAIN__' bus='0x__ETH3VF1PCIBUS__' slot='0x__ETH3VF1PCISLOT__' function='0x__ETH3VF1PCIFUNC__'/>
            </source>
            <address type='pci' domain='0x0000' bus='0x00' slot='0x08' function='0x0'/>
            </interface>
            <console type="pty"/>
            <channel type="unix">
              <source mode="bind"/>
              <target type="virtio" name="org.qemu.guest_agent.0"/>
            </channel>
            <channel type="spicevmc">
              <target type="virtio" name="com.redhat.spice.0"/>
            </channel>
            <input type="tablet" bus="usb"/>
            <graphics type="spice" port="-1" tlsPort="-1" autoport="yes"/>
            <sound model="ich9"/>
            <video>
              <model type="virtio"/>
            </video>
            <redirdev bus="usb" type="spicevmc"/>
            <redirdev bus="usb" type="spicevmc"/>
            <memballoon model="virtio"/>
            <rng model="virtio">
              <backend model="random">/dev/urandom</backend>
            </rng>
          </devices>
      </domain>
  - path: /opt/F5Networks/onboarding/BIGIPDomainMACVTAPTemplate.xml
    permissions: 0644
    content: |
      <domain type="kvm">
          <name>__BIGIP_VM_NAME__</name>
          <metadata>
            <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0">
              <libosinfo:os id="http://libosinfo.org/linux/2022"/>
            </libosinfo:libosinfo>
          </metadata>
          <memory>__BIGIP_VM_MEMORY__</memory>
          <currentMemory>__BIGIP_VM_MEMORY__</currentMemory>
          <vcpu>__BIGIP_VM_VCPUS__</vcpu>
          <os>
            <type arch="x86_64" machine="q35">hvm</type>
            <boot dev="hd"/>
          </os>
          <features>
            <acpi/>
            <apic/>
            <vmport state="off"/>
          </features>
          <cpu mode="host-model"/>
          <clock offset="utc">
            <timer name="rtc" tickpolicy="catchup"/>
            <timer name="pit" tickpolicy="delay"/>
            <timer name="hpet" present="no"/>
          </clock>
          <pm>
            <suspend-to-mem enabled="no"/>
            <suspend-to-disk enabled="no"/>
          </pm>
          <devices>
            <emulator>/usr/bin/qemu-system-x86_64</emulator>
            <disk type="file" device="disk">
              <driver name="qemu" type="qcow2"/>
              <source file="__BIGIP_IMAGE_FILE__"/>
              <target dev="vda" bus="virtio"/>
            </disk>
            <disk type="file" device="cdrom">
              <driver name="qemu" type="raw"/>
              <source file="__BIGIP_CLOUDINIT_ISO__"/>
              <target dev="sda" bus="sata"/>
              <readonly/>
            </disk>
            <controller type="usb" model="qemu-xhci" ports="15"/>
            <controller type="pci" model="pcie-root"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <controller type="pci" model="pcie-root-port"/>
            <interface type="bridge">
              <source bridge="br0"/>
              <model type="virtio"/>
            </interface>
            <interface type="direct">
              <source dev="__ETH0VF1NAME__" mode="bridge"/>
              <model type="virtio"/>
            </interface>
            <interface type="direct">
              <source dev="__ETH2VF1NAME__" mode="bridge"/>
              <model type="virtio"/>
            </interface>
            <interface type="direct">
              <source dev="__ETH1VF1NAME__" mode="bridge"/>
              <model type="virtio"/>
            </interface>
            <interface type="direct">
              <source dev="__ETH3VF1NAME__" mode="bridge"/>
              <model type="virtio"/>
            </interface>
            <console type="pty"/>
            <channel type="unix">
              <source mode="bind"/>
              <target type="virtio" name="org.qemu.guest_agent.0"/>
            </channel>
            <channel type="spicevmc">
              <target type="virtio" name="com.redhat.spice.0"/>
            </channel>
            <input type="tablet" bus="usb"/>
            <graphics type="spice" port="-1" tlsPort="-1" autoport="yes"/>
            <sound model="ich9"/>
            <video>
              <model type="virtio"/>
            </video>
            <redirdev bus="usb" type="spicevmc"/>
            <redirdev bus="usb" type="spicevmc"/>
            <memballoon model="virtio"/>
            <rng model="virtio">
              <backend model="random">/dev/urandom</backend>
            </rng>
          </devices>
      </domain>
  - path: /opt/F5Networks/onboarding/netplan_template.yaml
    permissions: 0644
    content: |
      network:
        version: 2
        renderer: networkd
        ethernets:
          eth0:
            dhcp4: no
            dhcp6: no
            nameservers:
              addresses:
                - __DNS_1__
                - __DNS_2__
            virtual-function-count: 1
          eth1:
            dhcp4: no
            dhcp6: no
            nameservers:
              addresses:
                - __DNS_1__
                - __DNS_2__
            virtual-function-count: 1
          eth2:
            dhcp4: no
            dhcp6: no
            nameservers:
              addresses:
                - __DNS_1__
                - __DNS_2__
            virtual-function-count: 1
          eth3:
            dhcp4: no
            dhcp6: no
            nameservers:
              addresses:
                - __DNS_1__
                - __DNS_2__
            virtual-function-count: 1
          vf1:
            link: eth0
            dhcp4: no
            dhcp6: no
          vf2:
            link: eth1
            dhcp4: no
            dhcp6: no
          vf3:
            link: eth3
            dhcp4: no
            dhcp6: no
          vf4:
            link: eth4
            dhcp4: no
            dhcp6: no
        bonds:
          bond0:
            interfaces:
              - eth0
              - eth2
            parameters:
              mode: 802.3ad
              lacp-rate: fast
              mii-monitor-interval: 100
              transmit-hash-policy: layer3+4
              all-slaves-active: true
              up-delay: 0
              down-delay: 0
          bond1:
            interfaces:
              - eth1
              - eth3
            addresses: [__PUBLIC_IP_ADDRESS__/__PUBLIC_IP_MASK__]
            gateway4: __PUBLIC_NEXT_HOP__
            nameservers:
              addresses:
                - __DNS_1__
                - __DNS_2__
            parameters:
              mode: 802.3ad
              lacp-rate: fast
              mii-monitor-interval: 100
              transmit-hash-policy: layer3+4
              all-slaves-active: true
              up-delay: 0
              down-delay: 0
        bridges:
          br0:
            addresses: [__PRIVATE_IP_ADDRESS__/__PRIVATE_IP_MASK__, __HOST_LINK_LOCAL_MANAGEMENT_IP__]
            interfaces: [bond0]
            nameservers:
              addresses:
                - __DNS_1__
                - __DNS_2__
            routes:
              - to: 10.0.0.0/8
                via: __PRIVATE_NEXT_HOP__
              - to: 161.26.0.0/16
                via: __PRIVATE_NEXT_HOP__
              - to: 166.8.0.0/14
                via: __PRIVATE_NEXT_HOP__
  - path: /opt/F5Networks/onboarding/BIGIPUserDataTemplate.yaml
    permissions: 0644
    content: |
      #cloud-config
      chpasswd:
        list: |
          root:__TMOS_ADMIN_PASSWORD__
          admin:__TMOS_ADMIN_PASSWORD__
        expire: False
      ssh_authorized_keys:
        - ssh-rsa [ __BIGIP_SSH_AUTH_KEY__ ]
      tmos_static_mgmt:
        enabled: true
        icontrollx_trusted_sources: false
        ip: __BIGIP_MANAGEMENT_IP__
        gw: __BIGIP_MANAGEMENT_NEXT_HOP__
        mtu: __BIGIP_MANAGEMENT_MTU__
        # post_onboard_enabled: true
        # post_onboard_commands:
        #  - tmsh create net trunk slPrivate interfaces replace-all-with { 1.1 1.2 }
        #  - tmsh create net trunk slPublic interfaces replace-all-with { 1.3 1.4 }
        #  - tmsh create net trunk customerPrivate interfaces replace-all-with { 1.5 1.6 }
        #  - tmsh create net trunk customerPublic interfaces replace-all-with { 1.7 1.8 }
      tmos_declared:
        enabled: true
        icontrollx_trusted_sources: false
        do_declaration:
          schemaVersion: 1.0.0
          class: Device
          async: true
          label: Cloudinit Onboarding
          Common:
            class: Tenant
            bigipSystem:
              class: System
              hostname: __BIGIP_HOSTNAME__
              autoPhonehome: false
            mgmtIp:
              class: ManagementIp
              address: __BIGIP_MANAGEMENT_IP__
            provisioningLevels:
              class: Provision
              ltm: nominal
            dnsServers:
              class: DNS
              nameServers:
                - __DNS_1__
                - __DNS_2__
      #      slPrivate:
      #        class: Trunk
      #        interfaces:
      #          - "1.1"
      #          - "1.2"
      #      slPublic:
      #        class: Trunk
      #        interfaces:
      #          - "1.3"
      #          - "1.4"
      #      customerPrivate:
      #        class: Trunk
      #        interfaces:
      #          - "1.5"
      #          - "1.6"
      #      customerPublic:
      #        class: Trunk
      #        interfaces:
      #          - "1.7"
runcmd: [nohup sh -c '/opt/F5Networks/onboarding/onboarding.sh' >> /var/log/F5NetworksBIGIPOnboard.log &]
